Rule System? WHAT FOR!?
==================

>If you want to get anywhere in life, don’t break the rules — make the rules! © *CLIPS User’s Guide*

*Rule-based system is a logical program that uses 
predefined rules to make deductions and choices to perform automated actions.*

> The text below had been compiled from different sources, but mainly from: "Core Techniques and Algorithms in Game Programming" by Daniel Sánchez-Crespo Dalmau
 © 

Imagine the following description of some doggo:

    - If there's a bone nearby and I'm hungry, I'll eat it.
    - If I'm hungry (but there is no bone in sight), I will wander.
    - If I'm not hungry, but I'm sleepy, I will sleep.
    - If I'm not hungry and not sleepy, I'll bark and walk.

We have four propositions that we might implement in a form of FSM, for example. 

Clearly, each proposition implies a state, and each state could be transitioned to all the others.

Something is not quite right here, but we can't tell what it is.

It is notorious that FSMs are best suited to define behaviors which kinda have:

- Local in nature (for every certain state, only 	an enumerable set of possible transitions are allowed)

- Sequential in nature (we carry out actions one by one).

A poor doggo described above isn't local if you pardon the pun. If we look closer, we could see all doggo's states can yield any other state, thus the model is not local at all. Also, there are no determined sequences. All the dog actually does is act according to some priorities or rules. 

Luckily, there is one way to model this kind of prioritized, global behavior. It is a rule system (**RS**), and it allows us to model many behaviors, including random ones and changing ones, that could be a bit too complicated to be modeled as FSMs.

At the core of an RS, there is a set of rules that drive our AI's behavior. Each rule has the form:

Condition => Action

The condition is also known as the left-hand side (LHS) of the rule, whereas the action is the right-hand side (RHS) of the rule. Thus, we specify the circumstances that activate the rule as well as which actions to carry out if the rule is active. In the previous dog example, a more formal specification of the system would be

    (Hungry) && (Bone nearby) => Eat it
    (Hungry) & (No bone nearby) => Wander
    (Not hungry) & (Sleepy) => Sleep
    (Not hungry) & (Not sleepy) => Bark and walk

Notice how we enumerated the rules and separated the condition from the actions in a more or less formal way.

The execution of an RS is really straightforward. We test the LHS of each expression (the conditions) in order and then execute the RHS (the action) of the first rule that is activated. This way, RSs imply a sense of priority. A rule closer to the top will have precedence over a rule closer to the bottom of the rule list.


RSs, as opposed to FSMs, provide a global model of behavior. At each execution cycle, all rules are tested, so there are no implied sequences. This makes them better suited for some AIs. 

Specifically, RSs provide a better tool when we need to model behavior that is based on guidelines. We model directions as rules, placing the more important ones closer to the top of the list, so they are priority executed. 

Let's look at a more involved example, so I can provide more advice on RSs. Imagine that we need to create the AI for a soldier in a large squadron. The rule system could be:

    1. If in contact with an enemy => combat
    2. If an enemy is closer than 10 meters and I'm stronger than him => chase him
    3. If an enemy is closer than 10 meters escape him => escape him
    4. If we have a command from our leader pending => execute it
    5. If a friendly soldier is fighting and I have a ranged weapon => shoot at the enemy
    6. => Stay still

Again, just six rules are sufficient to describe the behavior of a relatively complex system. Now, the clever placement of the rules could allow some elegant design. If the soldier is in the middle of combat with an enemy but is given an order by the leader, he will ignore the order until he kills the enemy, because the _combat_ rule is higher on the priority list than the "follow order" rule. 

Hence lies the beauty of RSs. Not only can we model behaviors, but we can also model behavior layering or how we process the concept of relevance.

In addition, notice how the last rule does not have a condition but is more a "default action." It is relatively normal to have the last rule that is always true. 

Once designed, RSs are very easy to actually code. 

Further reading
===============
-   [Why use a Rule Engine?](http://www.jbug.jp/trans/jboss-rules3.0.2/ja/html/ch01s02.html)
- [What is a rule-based system? What is it not?](https://www.thinkautomation.com/eli5/what-is-a-rule-based-system-what-is-it-not/)
-   [Scott Kovach - Managing Game Logic With Rule Systems](https://youtu.be/s9Wyn9BJJI4)